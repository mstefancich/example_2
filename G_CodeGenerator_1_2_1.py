# THIS VERSION IS A FORM OCCURRED ON NOV 16th 2022 to accomodate the current controller
# based on M118 commands as from the Etcher Version 2 hardware.

# bugfix 20200402 on April 2nd: a space is needed between the movement command (e.g. G01) and the
# displacement (e.g. X10Y20E50). Added on April 2nd.
# bugfix 20200403 on April 2nd: again a space is inserted between EACH coordinate in the G00 and G01
# commands. Apparently Repetier Host is not confortable with the sintax with no spaces.
# version 1.1.0
# we added the option, controlled by the dictionary 'NumberOfPasses' keyword
# to pass multiple times on the pattern. If the keyword is not present or its value is set to 1
# a single pass will be done, otherwise the Gcode will be repeated the indicated number of times
# version 1.1.1
# OCT 13th. We added support for single position "paths" representing dwells where the
# etcher must remain stationary and etch for a given amount of time stored in the
# 'DwellTime' entry in the config file
# in any case, as single point pathes were not treated previously and not generated by
# the Gerber_translator, the addition does not break any preexisting functionality
# JAN 11 2021:
# It would be good to maintain the pump on while we perform the movements
# to maintain the jet pressure.
# To add this feature, we need to modify the G_code_translate_path making it take (and return)
# an extra paramer being the current position when it is invokedt (and it returns the
# final position after the path execution).
# this parameter is used to calculate the length of the movement and, consequently, the pump value
#
# second modification: 'RepetitionMode'
# based on this entry in the config dictionary (that can be Single or All) we repeat the pattern
# in different ways. if set to "Single" each closed loop will be repeated multiple times
# if set to "All" the whole pattern will be repeated instead. In both cases the numer of
# repetitions is given by 'NumberOfPasses'
# N.B. the "All" mode is not currently compatible with the use of a drill file (as the drills will be repeated multiple times)

# NOV 16. Main fork
# NOW 16th. we modified the TURN-ON/TURN off current command to M118 A1 SET_CURRENT xxmA
# we also added at the code beginnig a M118 ACTIVE ON (to set the control board in a "ready" state)
# and finally we added a M118 END at the end of the Gcode to turn off the HV generator of the current controller
# Dec 5th 2024
# adapted the code (both startup and etch) to the new format of commands.
# the result is OK.
# however, as our workpiece is inclined, I need also to correct the Z based on the Y (and a bit on the X) move.
# two new fields have been added to the config file being  'dZ/dY': 0.174375 and 'dZ/dX': 0.0215.
# this impacts only the moves (both during travel and etch) and requires adding a dZ calculated
# from the last X and Y values and the current ones.
# we need to extend all the "pos" (e.g. current_pos) to 3 dimensions.
# a new minor code version update is saved 1_2_1
# Dec 10th 2024
# added a small pause after issuing the "current off" command as it appeared that a move
# would occurr before the current went 

# built-in packages
#import pprint
#import math
import numpy as np
import pickle
import os

Version="05 Dec 2024"
# this is where all the process parameters are stored
# can be manually edited or processed via Configuration_manager_1.0.py
#FileName = 'ConfigFile'
#SubDir = 'config_dir' # it is the local subdir present in the folder structure
# where this code is stored. ./config_dir/ConfigFile.py
# format for numerical data savin on file
formato="{:.4f}"
total_etch_length=0
total_travel_length=0

def initialize_dict(ConfigDict=0): # updated and working June 4th 2020
    try:
        SessionKey=str(ConfigDict['SessionKey'])
        print('Using Existing Dictionary')
        print('Session Key='+SessionKey)
    except:
        # no key defined yet, so we need to upload the dictionary
        print('Loading Default Dictionary')
        try:
            from config_dir import ConfigFile
            ConfigDict=ConfigFile.dict
            print("Config data uploaded.")            
        except:
            print("Config data not present. Data needed to proceed.")
    return(ConfigDict)

            
        #ConfigDict=ConfigFile.dict
    
def Load_Data(ConfigDict): # updated and working June 4th 2020   
    #TextInputFileName=ConfigDict['TextArchiveFileName']
    print('Loading Pickle Binary data from: ',os.path.join(ConfigDict['RootDirectory'],ConfigDict['PickleArchiveFileName']))
    try:
        #InFile=open(dict['RootDirectory']+'\\'+dict['PickleArchiveFileName'],"rb")
        InFile=open(os.path.join(ConfigDict['RootDirectory'],ConfigDict['PickleArchiveFileName']),"rb")
        InData=pickle.load(InFile)
    except:
        print("Pickle source data Missing")
        print("Attempting to source data in text file format")
        print('Loading Text Format data from: ',ConfigDict['TextArchiveFileName'])
        try:
            #InFile=open(dict['RootDirectory']+'\\'+dict['TextArchiveFileName'],"r")
            InFile=open(os.path.join(ConfigDict['RootDirectory'],ConfigDict['TextArchiveFileName']),"r")
            InData=load_text_data(InFile)
        except:
            print('Text Format data Missing\nExiting')
            return(-1)
        else:
            print('Loaded Text Format data')
            #print(InData)
            InFile.close()
    else:
        print("Binary source data Uploaded")
        InFile.close()
    # saves the dict content settings in comment form in the output file
    # and writes the initial set of instructions to setup the printer
    return(InData)

def G_code_translate_path(ConfigDict, file=(), isolation_path=(), current_pos=np.array((0,0,0))):
    # s=isolation_path contains a single closed path that must be etched (This code will be called separately on every separate element of the etching pattern)
    # as the current position is not already on this path initial point, the system must TRAVEL (no current) to its initial point
    # then current must be turned on as with the value indicated in the ConfigDict and the path must be followed at MOVE speed
    # once back at its initial point, current goes off.
    
    # sets the necessary variables
    PumpSpeed=float(ConfigDict['PumpSpeed'])
    MovSpeed=float(ConfigDict['MoveSpeed'])
    TravelSpeed=float(ConfigDict['TravelSpeed'])
    NozzleCurrent=float(ConfigDict['NozzleCurrent']) # expressed in Amps
    MaxNozzleCurrent=float(ConfigDict['MaxNozzleCurrent']) # expressed in Amps
    Z_derivative=float(ConfigDict['dZ/dX']),float(ConfigDict['dZ/dY']) # indicates the slope of the plane
    Z_derivative=np.array(Z_derivative)
    PWM_VALUE=int(5+(NozzleCurrent/MaxNozzleCurrent*245))
    global total_etch_length, total_travel_length
    if PWM_VALUE>250: PWM_VALUE=250 # extra passive safety...
    skipped=0;
    total=0 ;
    if(NozzleCurrent>MaxNozzleCurrent): # added Dec 4th
        NozzleCurrent=MaxNozzleCurrent
        print("WARNING: Nozzle Current Setting exceeds Max Nozzle Current Setting. Reducing to Max allowable value")
    # before the fork 16 Nov
#    ON_sequence=['M400\n'+'M106 S'+str(PWM_VALUE)+
#                 '\n','G4 P200\n','M107\n'+'G01 F'+str(MovSpeed)+'\n']
#    OFF_sequence=['M400\n','M106 S3\n','G4 P200\n','M107\n']
    # after the fork 16 Nov
    # only extra note... we need the actual current value and not the PWM
    # (as convertion is board dependent, it is better to convert it ON the board)
#     ON_sequence=['M400\n'+'M118 SET_CURRENT '+str(NozzleCurrent)+
#                  '\n'+'G01 F'+str(MovSpeed)+'\n']
#     OFF_sequence=['M400\n'+'M118 SET_CURRENT 0mA\n']
    #updating on Dec 4th to the currently used command format:
    ON_sequence=['M400\n'+'M118 E1 CMD:GEN_SET_CURRENT: '+str(int(NozzleCurrent*1000))+
                 '\n'+'G01 F'+str(MovSpeed)+'\n']
    OFF_sequence=['M400\n'+'M118 E1 CMD:GEN_SET_CURRENT: 0\n'+
                  'G04 P500\n'+'G01 F'+str(TravelSpeed)+'\n']
    # movements generator
    # generates the initial movement to the path start
    # Jan 11 2021: it would be good to maintain the pump on while we perform
    # the movement to maintain the jet pressure.
    # however, we do not know where are we starting from the initial movement.
    # so we need to add this as some parameter
    #data=isolation_path[0] # adding a zero as 3rd coordinate...
    #X_target_pos=formato.format(data[0])
    #Y_target_pos=formato.format(data[1])
    
    # BEGIN addition Dec 5th 2024. We want to calculate the change in X, Y AND Z
    # as the isolation path is 2 dim, the change in Z depends only on the X and Y move
    # we start calculating the planar displacement
    XY_displacement=np.subtract(np.array(isolation_path[0]),current_pos[0:2]) # 2 dim X,Y vector
    # then we calculate,. based on it and on the dZ/dX and dZ/dY slopes, the Z_displacement
    Z_displacement=np.dot(XY_displacement,Z_derivative) # derivative calculated Z-displacement
    # finally we reconstruct the 3D displacement.
    displacement=np.array((XY_displacement[0],XY_displacement[1],Z_displacement)) # 3D displacement
    travel_distance=np.linalg.norm(displacement)
    #X_move=formato.format(isolation_path[0][0]) # or X_move=formato.format(current_pos[0]+displacement[0])
    #Y_move=formato.format(isolation_path[0][1]) # or Y_move=formato.format(current_pos[1]+displacement[1])
    #Z_move=formato.format(current_pos[2]+displacement[2])
    # and the final target position is necessarily the current one plus the displacement (in 3D)
    next_pos=current_pos+displacement # 3d vector
    X_move=formato.format(next_pos[0])
    Y_move=formato.format(next_pos[1])
    Z_move=formato.format(next_pos[2])
    # as in the new etcher the pump is controlled independently through another channel, the following part will need to be modified to remove pump control
    #pump_displacement=formato.format(travel_distance/TravelSpeed*PumpSpeed)  # Removed pump part Dec 4th 2024
    # DONE add a Z move based on the dZ/dY and dz/Dx
    # TODO consider the geometrical deformation effect due to the slope
    # where, essentially, dY->dY*cos(Alpha) as, otherwise, the Y moves are amplified
    # due to the fact that the plate is sloped in the Z direction.
    # same for the X, but negligible as the Dz/Dx should be small with respect to dZ/Dy
    out=[str('G00 F'+str(TravelSpeed)+'\n'+'G00 X'+X_move+' Y'+Y_move+' Z'+Z_move)+'\n'] # Removed pump part Dec 4th 2024, Added Z_move Dec 5th
    total_travel_length=total_travel_length+travel_distance
    current_index=0
    #print('New_pos at index: '+str(current_index)+' is: ',next_pos)
    # END of code addition Jan 11th 2021
    # end of code modification Dec 4th 2024
    # END of code addition Dec 5th
    # in any case, after the move, we update the current_pos data including the Z 
    current_pos=next_pos # 3d vector
    
    # OCT 13th. what if the path contains a single point?
    # this means that it is a DWELL command... how do I treat it here?
    # isolation_path[1:] is, in this case [] and the cycle does not execute (but there is no error)
    # we check this beforehand and insert a specific sequence taking care of single points
    # we need also to avoid repeating this part for the number of desired paths (this is
    # done beloew adding an exception to the repetitions value that is forced to 1
    # when the isolation_path contains a single point.
    # this disappears in Dec 2024 version as the pump is controlled externally
    # we still need to turn  wait for some amount of time in place
    
    if len(isolation_path[1:])==0 : # then it is a single point...
        # We need to turn on the current (done afterwards), Dwell for ConfigDict['DwellTime'], turn off the current (done afterward)
        out.append(str('G04 P')+str(int(float(ConfigDict['DwellTime'])*1000))+'\n') # eg ['G04 P800']     
    for data in isolation_path[1:]: # if there is a single point this cycle does not execute as there are no data in
        total+=1
        current_index+=1
        # we do not need anymore to define the pump movement
        new_pos=np.array((data[0],data[1], 0)) # here we put a zero value, to be subsequently set, for the Z-coord
        displacement_XY=np.subtract((new_pos[0],new_pos[1]),(current_pos[0],current_pos[1])) # it is a 2D array 
        Z_displacement=np.dot(displacement_XY,Z_derivative) # this is the Z-correction
        # that we add to the current Z_pos to get the target Z value in new_pos
        new_pos[2]=current_pos[2]+Z_displacement

        travel_distance=np.linalg.norm(np.subtract(new_pos,current_pos))
        if travel_distance>=float(ConfigDict['Min_Segm_Length']):
            total_etch_length=total_etch_length+travel_distance
            X_move=formato.format(new_pos[0])
            Y_move=formato.format(new_pos[1])
            Z_move=formato.format(new_pos[2])
            #print('New_pos at index: '+str(current_index)+' is: ',new_pos)
            #print("and Move is: ",(X_move,Y_move,Z_move))
            # pump_displacement=formato.format(travel_distance/MovSpeed*PumpSpeed) #removed Dec 4th
            out.append(str('G01 X'+X_move+' Y'+Y_move+' Z'+Z_move)+'\n') 
            current_pos=new_pos
        else:
            #print('skipping move with length: '+str(formato.format(travel_distance))+' at index: '+str(current_index))
            skipped=skipped+1
    if (skipped>0):
        print('skipped',skipped,
              'out of',total,
              'segments because shorter than ',ConfigDict['Min_Segm_Length'],'mm')
    # save the data in the file
    # initial movement to start point with current off
    # version 1.1.0 improvement. The writing of the etching part of the sequence
    # is repeated for the number of times indicated in ConfigDict['NumberOfPasses']
    # (1 if not present)
    try:
        repetitions=int(ConfigDict['NumberOfPasses']) ;
    except:
        repetitions=1
    if len(isolation_path[1:])==0: # this is for zero length path being points where no multiple repetitions are suitable.
        repetitions=1
    # print('Repetitions set to: '+str(repetitions))
    # intial approach (done only once for each repeated closed pattern)
    file.write(out[0]) # only the initial move (with no current) is written in file for now...
    # turn on current only once before the repeated etching sequence
    for line in ON_sequence:
        file.write(line)
    # etching sequence repeated multiple times as requested depending on the value of
    # 'RepetitionMode': 'RepeatSingleLoop' repeats eact loop multiple times
    # 'RepetitionMode': 'RepeatAll' draws the whole plot and then repeats
    if(ConfigDict['RepetitionMode']=='Single'):
        for i in range(repetitions):
            file.write('; Start passage '+str(i+1)+' of '+str(repetitions)+'\n')       
            # movement data
            for lines in out[1:]: # leaves out the initial moevement...
                file.write(lines)
            file.write('; End passage '+str(i+1)+' of '+str(repetitions)+'\n')
    else: # in this case, we repeat each loop only once and then go over everything again
        #and again
        for lines in out[1:]:
            file.write(lines)

    # turns off the current at the end of the (multiple ?) passages
    for line in OFF_sequence:
        file.write(line)
    # sequence is finished.
    return(out) , current_pos

def load_text_data(InFile):
    Datas=[]
    Lines=[]
    line=''
    switch=True
    while switch:
        line=InFile.readline()
        if line=='':
            switch=False
        else:
            line=line.partition(',') # returns a 3-ple containing the two elements in 0 and 2 and the separator in 1
            if line[1]==',': # valid data line
                Lines.append((float(line[0]),float(line[2])))
            else: # separator line
                if Lines!=[]:
                    Datas.append(Lines)
                Lines=[]
    if Lines!=[]:
        Datas.append(Lines)
    return(Datas)

def Initial_Commands_Set(OutFile,ConfigDict): # updated and working June 4th 2020
    # saves the ConfigDict content settings in comment form in the output file
    for key in ConfigDict.keys():
        OutFile.write('; ')
        OutFile.write(key)
        OutFile.write('\t')
        OutFile.write(str(ConfigDict[key]))
        OutFile.write('\n')
    # writes the initial set of instructions to setup the printer
    OutFile.write('\n; **** STARTUP CODE ****\n')
    OutFile.write(';\n')
    OutFile.write('G21 ; coordinates in mm\n')
    OutFile.write('G90 ; absolute coordinates for XYZ and E motion\n')
    OutFile.write(';\n')
    OutFile.write('; activates HV gen and sets current to zero\n')
    try:
        OutFile.write('M118 E1 CMD:GEN_SET_HV: '+str(ConfigDict['GEN_SET_HV']).lower()+'\n') # HV gen voltage mode selected
        #print('DEBUG:: GEN_SET_HV set to '+str(ConfigDict['GEN_SET_HV']).lower())
    except:
        OutFile.write('M118 E1 CMD:GEN_SET_HV: false\n') # defaulting to HV gen low voltage mode        
    OutFile.write('M118 E1 CMD:GEN_SET_RUN: true\n') # Generator on
    OutFile.write('M118 E1 CMD:GEN_SET_CURRENT: 0\n') # current to zero
    OutFile.write('G04 P500 ; waits 500 mS\n')
    OutFile.write(';\n')
    # end of section
    OutFile.write('; Homes the system\n')
    OutFile.write(';G28 Y ; homes Y\n')
    OutFile.write(';M400 ; waits for commands completion\n')
    OutFile.write(';G28 X ; homes X\n')
    OutFile.write(';M400 ; waits for commands completion\n')
    OutFile.write(';G28 Z ; homes Z\n')
    OutFile.write(';M400 ; waits for commands completion\n')
    OutFile.write(';\n')
    # moves to a safe initial point
    OutFile.write('; Moves to a safe initial position\n')
    OutFile.write(';G00 F'+ConfigDict['TravelSpeed']+'\n')    
    InitPoint=ConfigDict['GCodeInitialPosition'] # should be an array of 3 elements
    OutFile.write(';G00 Z'+str(InitPoint[2])+ ' ; raises Z\n')
    OutFile.write(';M400 ; waits for commands completion\n')
    OutFile.write(';G00 X'+str(InitPoint[0])+' Y'+str(InitPoint[1])+' ; moves to starting X and Y\n')
    OutFile.write(';M400 ; waits for commands completion\n')
    OutFile.write('G92 X0 Y0 Z0 ; defines this as new "soft" home point\n') # from now on, we can assume we are in [0,0,0]
    OutFile.write(';\n')
    # turning on the pump
    OutFile.write('; primes the pump for set time in seconds\n')
    OutFile.write('M118 E1 CMD:PUMP_SET_DIR: false\n') # depends....
    OutFile.write('M118 E1 CMD:PUMP_SET_SPEED: '+ConfigDict['PumpSpeed']+'\n')
    OutFile.write('M118 E1 CMD:PUMP_SET_RUN: true\n')
    OutFile.write('G04 S'+str(ConfigDict['PumpPrimingTime'])+'\n')
    OutFile.write('M400 ; waits for commands completion\n')
    OutFile.write(';\n')
    OutFile.write('\n; **** END OF STARTUP CODE ****\n')
    OutFile.write(';\n')
    OutFile.write('\n; **** BEGINNING OF ETCHING CODE ****\n')
    return

def Final_Commands_Set(ConfigDict,OutFile): # updated and working June 4th 2020
    # writes a set of final instruction
    OutFile.write('\n; **** END CODE****\n')
    OutFile.write(';\n')
    OutFile.write('; de activates HV gen and sets current to zero\n')
    OutFile.write('M118 E1 CMD:GEN_SET_RUN: false\n') # Generator on
    OutFile.write(';\n')
    OutFile.write('M118 E1 CMD:PUMP_SET_RUN: false\n')
    OutFile.write(';\n')    
    OutFile.write('G91\n')
    OutFile.write('G00 Z5 F60; Moves Z up 5 mm\n')
    OutFile.write('G90\n')    
    OutFile.write('M400 ; waits for commands completion\n')
    OutFile.write('G00 F'+str(ConfigDict['TravelSpeed'])+'\n')
    OutFile.write('G00 X0 Y0 ; Homing\n')


def Generate_Gcode(ConfigDict=0):
    global total_etch_length, total_travel_length
    total_etch_length=0
    total_travel_length=0
    ConfigDict=initialize_dict(ConfigDict)
    if ConfigDict==0:
        print('Unrecoverable Error: aborting')
        return(-1)
    InData=Load_Data(ConfigDict)
    f=open(os.path.join(ConfigDict['RootDirectory'],ConfigDict['GCodeFileName']),"w")
    print("Saving Gcode in: "+os.path.join(ConfigDict['RootDirectory'],ConfigDict['GCodeFileName'])+"\n")
    Initial_Commands_Set(f,ConfigDict) # Updated this based on the current etcher commands format...
    # BEGIN second addition Jan11th 2021
    # if 'RepetitionMode' is set to 'All' in the dictionary, we repeat the full path
    # as many times as indicated in the 'NumberOfPasses' variable
    
    #BEGIN addition Jan 11th 2021
    current_pos=np.array((0,0,0)) # correct based on the final G92 X=0 Y=0 Z=0 in the Initial_Commands_Set
    if ConfigDict['RepetitionMode']=='All':
        FullRepeat=int(ConfigDict['NumberOfPasses'])
    else:
        FullRepeat=1
    try:
        for i in range(1,FullRepeat+1):
            if (FullRepeat>1):
                f.write('# BEGIN Global repetition '+str(i)+' of '+str(FullRepeat)+'\n')  
            for each in InData:
                # before jan 11th 2021 res,=G_code_translate_path(ConfigDict,f,each) # notice the , after res! it is critical otherwise you get a tuple instead of a list!
                res,current_pos=G_code_translate_path(ConfigDict,f,each,current_pos) # notice the , after res! it is critical otherwise you get a tuple instead of a list! # modified adding current_poss on Jan 11th 2021
                # END of addition 11th jan 2021
                # print(current_pos)
            if (FullRepeat>1):
                f.write('# END Global repetition '+str(i)+' of '+str(FullRepeat)+'\n')  
    except OSError as e:
        print('No data available for processing. Error: '+str(e))       
    else:
        print('data processed')
    Final_Commands_Set(ConfigDict,f)
    f.close()
    if (ConfigDict['RepetitionMode']=='Single'):
        Total_etch_length=int(ConfigDict['NumberOfPasses'])*total_etch_length
    else:
        Total_etch_length=total_etch_length
    Total_etch_time=str(int(Total_etch_length/int(ConfigDict['MoveSpeed'])+int(total_travel_length/int(ConfigDict['TravelSpeed']))+1+0.5))
    s1='Total etch length for '+str(ConfigDict['NumberOfPasses'])+' passes is '+str(int(Total_etch_length))+' mm\n'
    s1a='Total travel length for '+str(ConfigDict['NumberOfPasses'])+' passes is '+str(int(total_travel_length))+' mm\n'
    s2='Total etch time at '+(ConfigDict['MoveSpeed'])+' ('+(ConfigDict['TravelSpeed'])+')'+' mm/min is '+str(int(Total_etch_time))+' minutes\n'
    s3='G-code saved in: '+os.path.join(ConfigDict['RootDirectory'],ConfigDict['GCodeFileName']+'\n')
    print(s1+s1a+s2+s3)
    return((s1,s2))

#autoexeution
if __name__ == "__main__":
    print("Code Version: ",Version)
    verbose=1
    Generate_Gcode()

    